{"version":3,"sources":["index.js"],"names":["cards","to","i","x","y","scale","rot","Math","random","delay","trans","r","s","Deck","useState","Set","gone","useSprings","length","from","props","set","bind","useGesture","index","args","down","xDelta","delta","xDir","distance","direction","velocity","dir","add","isGone","has","window","innerWidth","undefined","config","friction","tension","size","setTimeout","clear","map","div","style","transform","interpolate","backgroundImage","render","document","getElementById"],"mappings":"8KAMMA,G,MAAQ,CACZ,yEACA,wEACA,sEACA,wEACA,wEACA,0EAIIC,EAAK,SAAAC,GAAC,MAAK,CACfC,EAAG,EACHC,GAAQ,EAALF,EACHG,MAAO,EACPC,IAA2B,GAAhBC,KAAKC,SAAV,GACNC,MAAW,IAAJP,IAIHQ,EAAQ,SAACC,EAAGC,GAAJ,2DAEVD,EAAI,GAFM,wBAGIA,EAHJ,sBAGmBC,EAHnB,MAKd,SAASC,IAAQ,IAAD,EACCC,oBAAS,kBAAM,IAAIC,OAA3BC,EADO,sBAEOC,YAAWjB,EAAMkB,QAAQ,SAAAhB,GAAC,kCAC1CD,EAAGC,IADuC,IAE7CiB,KAXe,CAAEhB,EAAG,EAAGG,IAAK,EAAGD,MAAO,IAAKD,GAAI,UAOnC,mBAEPgB,EAFO,KAEAC,EAFA,KAORC,EAAOC,aACX,YAOO,IANEC,EAMH,cANJC,KAMI,MALJC,EAKI,EALJA,KACQC,EAIJ,cAJJC,MAII,MAFQC,GAER,EAHJC,SAGI,cAFJC,UAEI,OADJC,EACI,EADJA,SAGMC,EAAMJ,EAAO,GAAK,EAAI,GACvBH,GAFWM,EAAW,IAELhB,EAAKkB,IAAIV,GAC/BH,GAAI,SAAAnB,GACF,GAAIsB,IAAUtB,EAAd,CACA,IAAMiC,EAASnB,EAAKoB,IAAIZ,GAIxB,MAAO,CACLrB,EAJQgC,GAAU,IAAME,OAAOC,YAAcL,EAAMP,EAAOC,EAAS,EAKnErB,IAJUqB,EAAS,KAAOQ,EAAe,GAANF,EAAWD,EAAW,GAKzD3B,MAJYqB,EAAO,IAAM,EAKzBjB,WAAO8B,EACPC,OAAQ,CAAEC,SAAU,GAAIC,QAAShB,EAAO,IAAMS,EAAS,IAAM,UAG5DT,GAAQV,EAAK2B,OAAS3C,EAAMkB,QAC/B0B,YAAW,kBAAM5B,EAAK6B,SAAWxB,GAAI,SAAAnB,GAAC,OAAID,EAAGC,QAAK,QAIxD,OAAOkB,EAAM0B,KAAI,WAAuB5C,GAAvB,IAAGC,EAAH,EAAGA,EAAGC,EAAN,EAAMA,EAAGE,EAAT,EAASA,IAAKD,EAAd,EAAcA,MAAd,OACf,cAAC,IAAS0C,IAAV,CAEEC,MAAO,CACLC,UAAWC,YACT,CAAC/C,EAAGC,IACJ,SAACD,EAAGC,GAAJ,4BAAyBD,EAAzB,cAAgCC,EAAhC,aALN,SAUE,cAAC,IAAS2C,IAAV,2BACMzB,EAAKpB,IADX,IAEE8C,MAAO,CACLC,UAAWC,YAAY,CAAC5C,EAAKD,GAAQK,GACrCyC,gBAAgB,OAAD,OAASnD,EAAME,GAAf,UAbdA,MAoBXkD,iBAAO,cAACvC,EAAD,IAAUwC,SAASC,eAAe,U","file":"static/js/main.ae073926.chunk.js","sourcesContent":["import { render } from 'react-dom';\nimport React, { useState } from 'react';\nimport { useSprings, animated, interpolate } from 'react-spring';\nimport { useGesture } from 'react-use-gesture';\nimport './styles.css';\n\nconst cards = [\n  'https://cs13.pikabu.ru/post_img/2020/12/11/10/1607704452142049893.webp',\n  'https://cs9.pikabu.ru/post_img/2020/10/23/10/1603474785143083278.webp',\n  'https://cs11.pikabu.ru/post_img/2020/09/25/9/16010462851751251.webp',\n  'https://cs12.pikabu.ru/post_img/2020/09/12/9/1599922517138788628.webp',\n  'https://cs10.pikabu.ru/post_img/2020/09/07/9/1599488551161482343.webp',\n  'https://cs12.pikabu.ru/post_img/2020/07/24/9/1595601311195765815.webp',\n];\n\n// These two are just helpers, they curate spring data, values that are later being interpolated into css\nconst to = i => ({\n  x: 0,\n  y: i * -4,\n  scale: 1,\n  rot: -10 + Math.random() * 20,\n  delay: i * 100,\n});\nconst from = i => ({ x: 0, rot: 0, scale: 1.5, y: -1000 });\n// This is being used down there in the view, it interpolates rotation and scale into a css transform\nconst trans = (r, s) =>\n  `perspective(1500px) rotateX(30deg) rotateY(${\n    r / 10\n  }deg) rotateZ(${r}deg) scale(${s})`;\n\nfunction Deck() {\n  const [gone] = useState(() => new Set()); // The set flags all the cards that are flicked out\n  const [props, set] = useSprings(cards.length, i => ({\n    ...to(i),\n    from: from(i),\n  })); // Create a bunch of springs using the helpers above\n  // Create a gesture, we're interested in down-state, delta (current-pos - click-pos), direction and velocity\n  const bind = useGesture(\n    ({\n      args: [index],\n      down,\n      delta: [xDelta],\n      distance,\n      direction: [xDir],\n      velocity,\n    }) => {\n      const trigger = velocity > 0.1; // If you flick hard enough it should trigger the card to fly out\n      const dir = xDir < 0 ? -1 : 1; // Direction should either point left or right\n      if (!down && trigger) gone.add(index); // If button/finger's up and trigger velocity is reached, we flag the card ready to fly out\n      set(i => {\n        if (index !== i) return; // We're only interested in changing spring-data for the current spring\n        const isGone = gone.has(index);\n        const x = isGone ? (200 + window.innerWidth) * dir : down ? xDelta : 0; // When a card is gone it flys out left or right, otherwise goes back to zero\n        const rot = xDelta / 100 + (isGone ? dir * 10 * velocity : 0); // How much the card tilts, flicking it harder makes it rotate faster\n        const scale = down ? 1.1 : 1; // Active cards lift up a bit\n        return {\n          x,\n          rot,\n          scale,\n          delay: undefined,\n          config: { friction: 50, tension: down ? 800 : isGone ? 200 : 500 },\n        };\n      });\n      if (!down && gone.size === cards.length)\n        setTimeout(() => gone.clear() || set(i => to(i)), 600);\n    },\n  );\n  // Now we're just mapping the animated values to our view, that's it. Btw, this component only renders once. :-)\n  return props.map(({ x, y, rot, scale }, i) => (\n    <animated.div\n      key={i}\n      style={{\n        transform: interpolate(\n          [x, y],\n          (x, y) => `translate3d(${x}px,${y}px,0)`,\n        ),\n      }}\n    >\n      {/* This is the card itself, we're binding our gesture to it (and inject its index so we know which is which) */}\n      <animated.div\n        {...bind(i)}\n        style={{\n          transform: interpolate([rot, scale], trans),\n          backgroundImage: `url(${cards[i]})`,\n        }}\n      />\n    </animated.div>\n  ));\n}\n\nrender(<Deck />, document.getElementById('root'));\n"],"sourceRoot":""}